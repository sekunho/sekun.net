<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Deploying Nix builds on Fly.io - sekun</title>

    <link rel="stylesheet" href="/assets/css/style.css"/>

    <link rel="icon" href="/assets/images/favicon.ico">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicon-16x16.png">
    <link rel="apple-touch-icon" href="/assets/images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicon-32x32.png">
    <link rel="mask-icon" href="/assets/images/safari-pinned-tab.svg">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/nix.min.js"></script>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="UTF-8">
    
<meta name="title" content="Deploying Nix builds on Fly.io" />
<meta name="description" content="The current approach Fly.io recommends doing is you write a Dockerfile to
build, and run your app on their platform. However, if you've already packaged
your application with nix, it would be nice to capitalize on that, and
throw it into a docker image somehow instead of having to create a
separate build process.
" />

<meta property="og:type" content="website" />
<meta property="og:url" content="https://metatags.io/" />
<meta property="og:title" content="Deploying Nix builds on Fly.io" />
<meta property="og:description" content="The current approach Fly.io recommends doing is you write a Dockerfile to
build, and run your app on their platform. However, if you've already packaged
your application with nix, it would be nice to capitalize on that, and
throw it into a docker image somehow instead of having to create a
separate build process.
" />
<meta property="og:image" content="https://sekun.net/assets/images/posts/deploying-nix-builds-to-fly-io/cover.jpg" />

<meta property="twitter:card" content="summary_large_image" />
<meta property="twitter:url" content="https://metatags.io/" />
<meta property="twitter:title" content="Deploying Nix builds on Fly.io" />
<meta property="twitter:description" content="The current approach Fly.io recommends doing is you write a Dockerfile to
build, and run your app on their platform. However, if you've already packaged
your application with nix, it would be nice to capitalize on that, and
throw it into a docker image somehow instead of having to create a
separate build process.
" />
<meta property="twitter:image" content="https://sekun.net/assets/images/posts/deploying-nix-builds-to-fly-io/cover.jpg" />

  </head>

  <body>
    <nav class="nav">
  <ul>
    <li><a href="/">λsekun.net</a></li>
    <li><a href="/blog">/blog</a></li>
    <li><a href="/projects">/projects</a></li>
    <li><a href="/contact">/contact</a></li>
  </ul>
</nav>
    
<h1>Deploying Nix builds on Fly.io</h1>
<div>


</div>
<div>

  <x-img>
    <template shadowrootmode="open">
      <img src="/assets/images/posts/deploying-nix-builds-to-fly-io/cover.jpg" alt="Fly.io, and NixOS logos shaking hands"/>

      <style>
        x-img-foo:not(:defined) > template[shadowrootmode] ~ * {
          display: none;
        }

        img {
          

          
          width: 100%;
          

          display: block;
          margin: 1rem auto;
        }
      </style>
    </template>
  </x-img>

</div>
<span class="post-metadata">
  Published on <time datetime="2024-10-18T14:48:52+00:00">2024-10-18 14:48 UTC</time>
</span>
<p><em>In 9 days it would’ve been 2 years since I last posted. Wow time does… <strong>Fly</strong></em>.</p>
<p>Around a month ago, I was messing around with <a href="https://fly.io">Fly.io</a> + <code>nix</code>
for a toy project, and <a href="https://twitter.com/sekunho_/status/1835016387133350146">tweeted</a>
about the experience. There I was asked by <a href="https://twitter.com/GemmaBlackUK">@GemmaBlackUK</a>
if I had written an article about it, and thought well maybe it would make a
nice article to start with after years of ignoring this blog. So here’s a debut
article for my new blog engine (that I may rewrite yet again in a year).</p>
<hr />
<p>The current approach Fly.io recommends doing is you write a <code>Dockerfile</code> to
build, and run your app on their platform. However, if you’ve already packaged
your application with <code>nix</code>, it would be nice to capitalize on that, and throw
it into a docker image somehow instead of having to create a separate build process.
This means reusing the exact tooling present in your nix dev shell down to the
exact commit.</p>
<p>But do not fret, you <em>can</em> do something like that! Just with slightly more work.</p>
<h2>Prerequisites</h2>
<p>You’ll need to have the following installed:</p>
<ul>
<li><code>nix</code> with flakes enabled</li>
</ul>
<p>The rest of the tools needed will be supplied by <code>nix</code> in a dev shell we’ll make.</p>
<p>To start everything off, let’s make a <code>flake.nix</code> by running <code>nix flake init</code>
in your directory of choice. This generates the file with the following:</p>
<pre><code class="language-nix"># flake.nix
{
  description = "A very basic flake";

  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs?ref=nixos-unstable";
  };

  outputs = { self, nixpkgs }: {
    # NOTE: You can delete this
    packages.x86_64-linux.hello = nixpkgs.legacyPackages.x86_64-linux.hello;

    # NOTE: and this because we don't need them
    packages.x86_64-linux.default = self.packages.x86_64-linux.hello;
  };
}
</code></pre>
<p>The application that’s gonna run in the image is one that reads an environment
variable <code>APP_ECHO_ME</code>, and renders it into an HTML page served by <code>axum</code>. The
environment will be set through Fly secrets.</p>
<blockquote>
<p>You can find it in this <a href="https://github.com/sekunho/webecho">GitHub repository</a>.
Though if you have one to already tinker with, feel free to skip to the next
section.</p>
</blockquote>
<p>The gist of it is <code>webecho</code> looks for the environment variable <code>APP_ECHO_ME</code>,
and renders it into an HTML page that’s served by axum.</p>
<pre><code class="language-rust">// main.rs
use axum::{response::Html, routing, Router};

#[tokio::main]
async fn main() {
    // please dkm for unwraps
    let app = Router::new().route("/echo", routing::get(echo));
    let listener = tokio::net::TcpListener::bind("0.0.0.0:8080").await.unwrap();
    axum::serve(listener, app).await.unwrap();
}

async fn echo() -&gt; Html&lt;String&gt; {
    match std::env::var("APP_ECHO_ME") {
        Ok(val) =&gt; Html(format!("&lt;h1&gt;{val}&lt;/h1&gt;")),
        Err(_) =&gt; Html(format!("bruh")),
    }
}
</code></pre>
<p>Which we packaged with <code>nix</code> like so</p>
<pre><code class="language-nix"># flake.nix
{
  inputs = {
    # We set the nix packages repo to the latest stable (at the time of writing)
    nixpkgs.url = "github:NixOS/nixpkgs/nixos-24.05";
    # Used for packaging rust applications
    crane.url = "github:ipetkov/crane";

    # Used for setting up rust toolchain
    fenix = {
      url = "github:nix-community/fenix";
      inputs.nixpkgs.follows = "nixpkgs";
      inputs.rust-analyzer-src.follows = "";
    };
  };

  outputs = { self, nixpkgs, crane, fenix }:
    let
      system = "x86_64-linux";
      pkgs = import nixpkgs { inherit system; };

      # We're telling crane about the rust toolchain we want to use
      craneLib = (crane.mkLib pkgs).overrideToolchain
        fenix.packages.${system}.stable.toolchain;

      # Project source for crane to look in
      src = pkgs.lib.cleanSourceWith {
        src = ./.;

        filter = path: type:
          (craneLib.filterCargoSources path type)
        ;
      };

      commonArgs = {
        inherit src;
        version = "0.1.0";
        strictDeps = true;
        pname = "webecho";
        name = "webecho";
        buildInputs = [ ];
        nativeBuildInputs = [ ];
      };

      cargoArtifacts = craneLib.buildDepsOnly commonArgs;

      webecho = craneLib.buildPackage (commonArgs // {
        inherit cargoArtifacts;
        doCheck = false;
        CARGO_PROFILE = "release";
      });
    in
    {
      packages.${system} = { inherit webecho; };

      # `nixpkgs-fmt`, and `nil` are optional. They're just helpful for working
      # with nix source files. Though `dive`, and `flyctl` are tools used in this
      # article.
      devShells.${system}.default = craneLib.devShell {
        packages = with pkgs; [ nixpkgs-fmt nil dive flyctl ];
      };
    };
}
</code></pre>
<p>We can run <code>webecho</code> with <code>nix run .#webecho</code>, and then visit <code>http://localhost:8080/echo</code>.</p>
<div>

  <x-img>
    <template shadowrootmode="open">
      <img src="/assets/images/posts/deploying-nix-builds-to-fly-io/webecho_bruh.png" alt=""/>

      <style>
        x-img-foo:not(:defined) > template[shadowrootmode] ~ * {
          display: none;
        }

        img {
          

          
          width: 100%;
          

          display: block;
          margin: 1rem auto;
        }
      </style>
    </template>
  </x-img>

</div>
<p>and <code>APP_ECHO_ME="nix fixes this" nix run .#webecho</code></p>
<div>

  <x-figure>
    <template shadowrootmode="open">
      <figure>
        <img src="/assets/images/posts/deploying-nix-builds-to-fly-io/webecho_nix_fixes_this.png" alt=""/>
        <figcaption><slot></slot></figcaption>
      </figure>

      <style>
        figure {
          

          

          display: block;
          margin: 1.5rem auto;

          img {
            width: 100%;
          }

          figcaption {
            text-align: center;
            color: #a89984;
            font-style: italic;
          }
        }
      </style>
    </template>
    
    now you sound like the average nixos user on twitter dot com

  </x-figure>

</div>
<h2>Building the container image with nix</h2>
<p><code>nix</code> has a few options for creating images<sup class="footnote-reference"><a href="#1">1</a></sup> but the one we’ll be using is
<code>pkgs.streamLayeredImage</code><sup class="footnote-reference"><a href="#2">2</a></sup>. It has a bunch of attributes in it but we’re only
interested in a couple of them. Specifically these:</p>
<pre><code class="language-nix">pkgs.streamLayeredImage {
    name = "webecho";
    tag = "latest";
    contents = [ self.packages.${system}.webecho ];

    config = {
      Cmd = [ "/bin/webecho" ];
    };
}
</code></pre>
<p>So the NixOS manual says this about the <code>contents</code> attribute:</p>
<blockquote>
<p>Directories whose contents will be added to the generated image. Things that
coerce to paths (e.g. a derivation) can also be used. This can be seen as an
equivalent of <code>ADD contents/ /</code> in a Dockerfile.</p>
<p>All the contents specified by contents will be added as a final layer in the
generated image. They will be added as links to the actual files (e.g. links
to the store paths). The actual files will be added in previous layers.</p>
</blockquote>
<p>Which is something we want for our <code>webecho</code> application since it’s what gets
executed when the container runs.</p>
<p>And build it like how we build <code>webecho</code> earlier. Only this time, this will build
both the <code>webecho</code> application, and the image.</p>
<pre><code class="language-sh">$ nix build .#webechoImg
</code></pre>
<p>The generated image is stored in a <code>tar</code> file which we have to load into <code>docker</code>
as an image.</p>
<pre><code class="language-sh">$ ./result | docker image load
No 'fromImage' provided
Creating layer 1 from paths: ['/nix/store/zvwpisszhpkkk8spqyya8n3bpm7wj39p-libunistring-1.1']
Creating layer 2 from paths: ['/nix/store/9jivp79yv91fl1i6ayq2107a78q7k43i-libidn2-2.3.7']
Creating layer 3 from paths: ['/nix/store/2y852kcvb7shrj8f3z8j22pa0iybcbgj-xgcc-13.2.0-libgcc']
Creating layer 4 from paths: ['/nix/store/c10zhkbp6jmyh0xc5kd123ga8yy2p4hk-glibc-2.39-52']
Creating layer 5 from paths: ['/nix/store/yfd49ay99aa1a0jg80jsvnxbyl61fsh6-gcc-13.2.0-libgcc']
Creating layer 6 from paths: ['/nix/store/swcl0ynnia5c57i6qfdcrqa72j7877mg-gcc-13.2.0-lib']
Creating layer 7 from paths: ['/nix/store/5w470zmki3wby35ki8ql3xhrd8x450lf-webecho']
Creating layer 8 with customisation...
Adding manifests...
Done.
14d9ed21e5fa: Loading layer [==================================================&gt;]    983kB/983kB
18dc56492fda: Loading layer [==================================================&gt;]  10.24kB/10.24kB
The image webecho:latest already exists, renaming the old one with ID sha256:71901dfab2e5a591cf264891021db0bc258927788db5786f18fbbb8835fc6b5e to empty string
Loaded image: webecho:latest
</code></pre>
<p>You can look around the image with <code>dive webecho:latest</code>.</p>
<div>

  <x-img>
    <template shadowrootmode="open">
      <img src="/assets/images/posts/deploying-nix-builds-to-fly-io/webecho_dive.png" alt=""/>

      <style>
        x-img-foo:not(:defined) > template[shadowrootmode] ~ * {
          display: none;
        }

        img {
          

          
          width: 100%;
          

          display: block;
          margin: 1rem auto;
        }
      </style>
    </template>
  </x-img>

</div>
<p>Then you can run this image as if it were any other image created from a <code>Dockerfile</code>!</p>
<pre><code class="language-sh">$ docker run -p 8080:8080 webecho:latest
</code></pre>
<p>And when we try to <code>curl</code> it</p>
<pre><code class="language-sh">$ curl http://localhost:8080/echo
bruh⏎
</code></pre>
<p>So far looks pretty good.</p>
<h2>Deploying to Fly.io</h2>
<p>This part shouldn’t differ too much from the usual deployment process.</p>
<p>First, login your Fly account with <a href="https://fly.io/docs/flyctl/auth-login/"><code>flyctl auth login</code></a>.
This opens a new tab in your browser for you to complete the login process.</p>
<pre><code class="language-sh">$ fly auth login
$ fly auth docker # authenticates your local docker to push to their container registry
$ fly apps create webecho # create an application called webecho under your account
</code></pre>
<p>Then we need to tag the image to something that Fly.io expects which is in the format
of <code>registry.fly.io/&lt;APP_NAME&gt;:&lt;VERSION&gt;</code>, and push it to their registry.</p>
<pre><code class="language-sh">$ docker image tag webecho:latest registry.fly.io/webecho:latest
$ docker push registry.fly.io/webecho:latest
The push refers to repository [registry.fly.io/webecho]
18dc56492fda: Pushed
14d9ed21e5fa: Pushed
f958be77db0f: Pushed
5a95ac30ae8b: Pushed
0dbac4a9743c: Pushed
6b971f7d0a50: Pushed
905fa559f035: Pushed
975a8857676b: Pushed
latest: digest: &lt;SHA265 OMITTED&gt; size: 1995
</code></pre>
<p>Finally, we create the <code>fly.toml</code> file</p>
<pre><code class="language-toml"># fly.toml
app = 'webecho'
primary_region = 'sea'

[build]
image = 'registry.fly.io/webecho:latest'

[deploy]
strategy = "rolling"

[http_service]
internal_port = 8080
force_https = true
auto_stop_machines = 'stop'
auto_start_machines = true
min_machines_running = 1
processes = ['app']

[[vm]]
size = 'shared-cpu-1x'
memory = "256mb"
cpus = 1

[checks.health]
type = "http"
method = "GET"
path = "/echo"
port = 8080
interval = "5s"
timeout = "5s"
</code></pre>
<p>And deploy!</p>
<pre><code class="language-sh">$ flyctl deploy -c fly.toml -a webecho
</code></pre>
<div>

  <x-img>
    <template shadowrootmode="open">
      <img src="/assets/images/posts/deploying-nix-builds-to-fly-io/webecho_bruh_on_fly.png" alt=""/>

      <style>
        x-img-foo:not(:defined) > template[shadowrootmode] ~ * {
          display: none;
        }

        img {
          

          
          width: 100%;
          

          display: block;
          margin: 1rem auto;
        }
      </style>
    </template>
  </x-img>

</div>
<blockquote>
<p>Your app’s URL will vary depending on what they give you. Check your app’s
dashboard just to be sure.</p>
</blockquote>
<p>Right. Forgot to set the environment variable!</p>
<pre><code class="language-sh">$ fly secrets set "APP_ECHO_ME=nix fixes this" -c fly.toml -a webecho
</code></pre>
<div>

  <x-img>
    <template shadowrootmode="open">
      <img src="/assets/images/posts/deploying-nix-builds-to-fly-io/webecho_nix_fixes_this_on_fly.png" alt=""/>

      <style>
        x-img-foo:not(:defined) > template[shadowrootmode] ~ * {
          display: none;
        }

        img {
          

          
          width: 100%;
          

          display: block;
          margin: 1rem auto;
        }
      </style>
    </template>
  </x-img>

</div>
<h2>Footnotes</h2>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="https://ryantm.github.io/nixpkgs/builders/images/dockertools">https://ryantm.github.io/nixpkgs/builders/images/dockertools</a></p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p><a href="https://nixos.org/manual/nixpkgs/unstable/#ssec-pkgs-dockerTools-streamLayeredImage">https://nixos.org/manual/nixpkgs/unstable/#ssec-pkgs-dockerTools-streamLayeredImage</a></p>
</div>


    <footer>
  <div>
    Copyright <a href="https://github.com/sekunho">SEKUN</a> 2022-2024.
    Generated by <a href="/projects/puggle"><code>puggle</code></a>.
  </div>
</footer>

    <script>hljs.highlightAll();</script>

    <script>
      (function attachShadowRoots(root) {
        root.querySelectorAll("template[shadowrootmode]").forEach(template => {
          const mode = template.getAttribute("shadowrootmode");
          const shadowRoot = template.parentNode.attachShadow({ mode });

          shadowRoot.appendChild(template.content);
          template.remove();
          attachShadowRoots(shadowRoot);
        });
      })(document);
    </script>
  </body>
</html>