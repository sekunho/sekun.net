<!DOCTYPE html>
<html lang="en">
  <head>
    <title>What I learned from building an emoji URL shortener in Rust - sekun</title>

    <link rel="stylesheet" href="/assets/css/style.css"/>

    <link rel="icon" href="/assets/images/favicon.ico">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicon-16x16.png">
    <link rel="apple-touch-icon" href="/assets/images/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicon-32x32.png">
    <link rel="mask-icon" href="/assets/images/safari-pinned-tab.svg">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/nix.min.js"></script>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="UTF-8">
    
<meta name="title" content="What I learned from building an emoji URL shortener in Rust" />
<meta name="description" content="Alright, that was a lot. I did learn a lot from this experience. I actually only
read until chapter 10 of the Rust Book, and skipped to some parts like advanced
traits, and other things. I really like the fact that there's a detailed book
that talks about some idiomatic Rust patterns, and even the more advanced stuff,
that's completely FREE. How crazy is that? My wallet is spared!
" />

<meta property="og:type" content="website" />
<meta property="og:url" content="https://metatags.io/" />
<meta property="og:title" content="What I learned from building an emoji URL shortener in Rust" />
<meta property="og:description" content="Alright, that was a lot. I did learn a lot from this experience. I actually only
read until chapter 10 of the Rust Book, and skipped to some parts like advanced
traits, and other things. I really like the fact that there's a detailed book
that talks about some idiomatic Rust patterns, and even the more advanced stuff,
that's completely FREE. How crazy is that? My wallet is spared!
" />
<meta property="og:image" content="https://sekun.net/assets/images/posts/what-i-learned-from-building-a-rust-emoji-url-shortener/cover.png" />

<meta property="twitter:card" content="summary_large_image" />
<meta property="twitter:url" content="https://metatags.io/" />
<meta property="twitter:title" content="What I learned from building an emoji URL shortener in Rust" />
<meta property="twitter:description" content="Alright, that was a lot. I did learn a lot from this experience. I actually only
read until chapter 10 of the Rust Book, and skipped to some parts like advanced
traits, and other things. I really like the fact that there's a detailed book
that talks about some idiomatic Rust patterns, and even the more advanced stuff,
that's completely FREE. How crazy is that? My wallet is spared!
" />
<meta property="twitter:image" content="https://sekun.net/assets/images/posts/what-i-learned-from-building-a-rust-emoji-url-shortener/cover.png" />

  </head>

  <body>
    <nav class="nav">
  <ul>
    <li><a href="/">Œªsekun.net</a></li>
    <li><a href="/blog">/blog</a></li>
    <li><a href="/projects">/projects</a></li>
    <li><a href="/contact">/contact</a></li>
  </ul>
</nav>
    
<h1>What I learned from building an emoji URL shortener in Rust</h1>
<div>

</div>
<div>

  <x-img>
    <template shadowrootmode="open">
      <img src="/assets/images/posts/what-i-learned-from-building-a-rust-emoji-url-shortener/cover.png" alt="HackerNews URL pointing to a shortened emojied.net URL"/>

      <style>
        x-img-foo:not(:defined) > template[shadowrootmode] ~ * {
          display: none;
        }

        img {
          

          
          width: 100%;
          

          display: block;
          margin: 1rem auto;
        }
      </style>
    </template>
  </x-img>

</div>
<span class="post-metadata">
  Published on <time datetime="2022-04-11T06:20:00+00:00">2022-04-11 06:20 UTC</time>
</span>
<p>So, I made an emoji URL shortener with Rust and shared it in some places
including the <a href="https://old.reddit.com/r/rust/comments/tznryk/i_made_my_first_project_with_rust_its_a_url/">Rust community</a>.
And oh man this is the first thing I made that got this many visitors which is
pretty nice knowing that people were curious enough to try it <del>despite them probably
feeling disgusted from me bringing such a thing to existence</del>.</p>
<ul>
<li>Repo: <a href="https://github.com/sekunho/emojied">https://github.com/sekunho/emojied</a></li>
<li>Website: <a href="https://emojied.net">https://emojied.net</a></li>
</ul>
<p>Some glowing ‚ú® reviews:</p>
<blockquote>
<p>‚ÄúThanks, I hate it.‚Äù ‚Äì Pay08, 2022</p>
</blockquote>
<blockquote>
<p>‚Äúdownvoted for being a menace to society.‚Äù ‚Äì MultiplyAccumulate, 2022</p>
</blockquote>
<blockquote>
<p>‚Äúblursed ‚Äú ‚Äì Jaxius3</p>
</blockquote>
<blockquote>
<p>‚Äú‚ÄúMade with regret.‚Äù Hahahaha. Excellent.‚Äù ‚Äì IronWhiskers, 2022</p>
</blockquote>
<blockquote>
<p>‚ÄúWhat is wrong with you?‚Äù ‚Äì Jeff</p>
</blockquote>
<div>

  <x-img>
    <template shadowrootmode="open">
      <img src="/assets/images/posts/what-i-learned-from-building-a-rust-emoji-url-shortener/stats.png" alt="Cloudflare stats page for emojied.net"/>

      <style>
        x-img-foo:not(:defined) > template[shadowrootmode] ~ * {
          display: none;
        }

        img {
          
          width: 50%;
          

          

          display: block;
          margin: 1rem auto;
        }
      </style>
    </template>
  </x-img>

</div>
<p>Here are some of the things I learned from building a simple project.</p>
<h2>Tech Stack</h2>
<p>After looking around, I decided to go with the following:</p>
<ul>
<li><code>axum</code> (web server)</li>
<li><code>maud</code> (HTML templates via Rust macros)</li>
<li><code>postgres</code> (persistent data storage and business logic)</li>
<li><code>sqitch</code> (database schema migration tool)</li>
<li><code>typescript</code> (you know what this is)</li>
<li><code>docker</code> (‚Äúsimple‚Äù deploys)</li>
<li><code>nix</code> (reproducible environments)</li>
</ul>
<h2>PostgreSQL Procedures</h2>
<p>Procedures are <em>extremely</em> cool although this isn‚Äôt exactly new to me. I‚Äôve been
experimenting with this in one of my previous, unfinished projects called GNAWEX
<sup class="footnote-reference"><a href="#1">1</a></sup> (One day I will finish it don‚Äôt you worry).</p>
<p>This allows you to implement some business logic in SQL, without having to
implement it in the application level. If ever PostgreSQL is a constant in your
project, and intend to rewrite the app from scratch, you might just end up having
to rewrite the glue rather than your business logic. <code>emojied</code> isn‚Äôt doing
anything too exciting though, so I can‚Äôt really demonstrate all that is cool
about it.</p>
<p>Okay, an example would be fetching a URL given an identifier, and incrementing
the <code>clicks</code> column by one. Here‚Äôs an example of a procedure that does exactly
that:</p>
<pre><code class="language-sql">CREATE FUNCTION app.get_url(query TEXT)
                          -- ^ This contains the emoji sequence `identifier`
  RETURNS TEXT
  LANGUAGE sql
  AS $$
    -- Considered as a "clicked" link whenever this gets triggered
    UPDATE app.links
      SET clicks = clicks + 1
      WHERE links.identifier = $1;

    -- Builds the URL so that I don't have to do this in the web server
    SELECT concat(scheme, '://', hosts.name, path) AS url
      FROM app.links
      JOIN app.hosts
      ON links.host = hosts.host_id
      WHERE links.identifier = $1;
  $$;
</code></pre>
<p>It‚Äôs a simple function that uses SQL as the language that expects any <code>TEXT</code>,
and returns a <code>TEXT</code> as well, which is a sequence of emojis, and the URL it
maps to respectively. Since whatever happens in this procedure is in the same
transaction as what called it, e.g (<code>SELECT * FROM app.get_url('üçäüåê')</code>), if any
of this fails, then it rolls back everything, including the incrementing of
<code>clicks</code>. If this was at the application level, I‚Äôd have to reach for whatever
transaction implementation it uses (like <code>Ecto.Multi</code>) which doesn‚Äôt make sense
in this case cause Postgres already natively supports transactions.</p>
<p>I try to make heavy use of stored procedures as long as it‚Äôs applicable.
Inserting to multiple tables with one function, fetching leaderboard entries,
etc.</p>
<h2>Error handling with implicit <code>From&lt;T&gt;</code></h2>
<p>Error handling is pretty nice with Rust, especially since I was never a fan of
exceptions since it made control flow so weird. Although that may be because I
never really invested that much time working with them. In Rust, I like that
you can do two things for errors: errors encoded as ADTs, or panic (unrecoverable).
Although I‚Äôm not entirely sure if all errors can be encoded in sum types, and
what can be done if ever one needs to recover from a panic. But for <code>emojied</code>,
I definitely don‚Äôt have to think about that.</p>
<p>What I did have to deal with was finding a more convenient way when dealing with
other <code>Error</code> types. For instance, there‚Äôs <code>tokio_postgres::Error</code>, then there‚Äôs
<code>env::VarError</code>, and if I need to bubble up these errors to the binary, I‚Äôm gonna
need a convenient enough way to do that otherwise I‚Äôm gonna have a difficult time.</p>
<p>Let‚Äôs say I have two errors, a database one, and an application one.</p>
<pre><code class="language-rust">enum AppError {
  Foo,
  Baz
}

enum DbError {
    FailedToConnect,
    InvalidTLSCert
}

fn some_db_action() -&gt; Result&lt;String, DbError&gt; {
    Err(DbError::FailedToConnect)
}

fn some_app_action() -&gt; Result&lt;String, AppError&gt; {
    let result1 = some_db_action()?;
    let result2 = some_db_action()?;

    Ok(result1)
}
</code></pre>
<p>This fails to compile, here‚Äôs what <code>rustc</code> says:</p>
<pre><code>error[E0277]: `?` couldn't convert the error to `AppError`
    |
212 | fn app_action() -&gt; Result&lt;String, AppError&gt; {
    |                    ------------------------ expected `AppError` because of this
213 |     let result1 = db_action()?;
214 |     let result2 = db_action()?;
    |                              ^ the trait `From&lt;url::DbError&gt;` is not implemented for `AppError`
    |
    = note: the question mark operation (`?`) implicitly performs a conversion on the error value using the `Fro
m` trait
    = note: required because of the requirements on the impl of `FromResidual&lt;Result&lt;Infallible, url::DbError&gt;&gt;`
 for `Result&lt;std::string::String, AppError&gt;`

For more information about this error, try `rustc --explain E0277`.
</code></pre>
<p>So it tells me that using <code>?</code> implicitly converts <code>DbError</code> to <code>AppError</code> via
the <code>From</code> trait. And because I do not have a trait instance like
<code>impl From&lt;DbError&gt; for AppError</code>, it fails.</p>
<p>Another thing is I somehow need to bubble up <code>DbError</code> up to the application
error somehow. The method I ended up using is to just add a field to the
<code>AppError</code> record. It‚Äôs a bit tiring to copy all the <code>DbError</code> variants over to
the <code>AppError</code> enum. I mean, it‚Äôs fine for this one since it doesn‚Äôt have that
many, but it becomes.</p>
<pre><code class="language-rust">enum AppError {
    DbError(DbError), // Hooray!
    Foo,
    Baz
}
</code></pre>
<p>And then I can create a <code>From&lt;DbError&gt;</code> instance:</p>
<pre><code class="language-rust">impl From&lt;DbError&gt; for AppError {
    fn from(e: DbError) -&gt; Self {
        AppError::DbError(e)
    }
}
</code></pre>
<p>Which compiles!</p>
<p>If I wanted to avoid <code>From</code>, I could do this:</p>
<pre><code>let result1 = db_action().map_err(|_| AppError::Foo)?;
</code></pre>
<p>Except it‚Äôs kinda annoying cause I have to do this at every call site. Although
there are times when I did end up using this.</p>
<h2>Application configuration</h2>
<p>While convenient, I can‚Äôt just hard-code everything into the application,
especially for a public project. There are a lot of sensitive data like certs,
and sometimes it‚Äôs just <em>more</em> convenient for whoever is using the application
to change stuff without touching the source code. In my case, I had to make it
flexible enough to change database credentials.</p>
<blockquote>
<p>A common way to do it is through environment variables.</p>
<p>e.g <code>PG__HOST="db.example.com" emojied</code>. So whenever I need to update stuff, all
I have to do is just change the environment variable, and I‚Äôm spared from
touching the source code!</p>
</blockquote>
<p>Here‚Äôs <code>emojied</code>‚Äôs config for it to run:</p>
<pre><code class="language-rust">pub struct AppConfig {
    /// Application host
    pub host: String,

    /// PostgreSQL config
    pub pg: tokio_postgres::Config,

    /// Pool manager config
    pub manager: ManagerConfig,

    /// Pool size
    pub pool_size: usize,

    pub ca_cert_path: Option&lt;String&gt;,
}
</code></pre>
<p>Then I created an associated function for it called <code>from_env/0</code> which returns
a <code>Result&lt;AppConfig, Error&gt;</code>. I‚Äôll talk about the <code>Error</code> part in the <code>Error Handling</code> section. Then I can use Rust‚Äôs <code>std::env</code> module to get a var‚Äôs value!</p>
<p>Here‚Äôs a tiny example:</p>
<pre><code class="language-rust">use std::env;

struct AppConfig {
  pg_host: String,
}

impl AppConfig {
  fn from_env() -&gt; Result&lt;AppConfig, Error&gt; {
      let host = env::var("PG__HOST")?;

      Ok(AppConfig { pg_host: host })
  }
}
</code></pre>
<blockquote>
<p>Side note: This kinda looks monadic, where it binds <code>AppConfig</code> to <code>host</code>, and
evaluates to <code>Error</code> and ‚Äúexits‚Äù otherwise.</p>
</blockquote>
<h2>Handling database‚Ä¶handler in <code>axum</code></h2>
<p>I created this database handle that has all the things I need to communicate
with the database server:</p>
<pre><code class="language-rust">pub struct Handle {
    pub pool: Pool,
}
</code></pre>
<p>It‚Äôs pretty simple. It‚Äôs a struct that has a <code>pool</code> field. Then I created two
more functions to make things more convenient: <code>new/1</code>, and <code>client/1</code>.</p>
<p><code>new(config: AppConfig) -&gt; Result&lt;Handle, Error&gt;</code> expects an <code>AppConfig</code> as an
argument, and if all goes well, then a new database handle with all the important
things in it. <code>client(&amp;self) -&gt; Result&lt;Pool, Error&gt;</code> expects a reference to
<code>self</code>, which is <code>Handle</code> in this case. This uses the DB pool to create a new
client. From this client, you can do DB queries with it.</p>
<pre><code class="language-rust">// Grabs a client from the pool
let client = handle.client().await?;

// Runs a query that gets a URL's stats
let data = client
    .query("SELECT * FROM app.get_url_stats($1)", &amp;[&amp;identifier])
    .await?;

// Manually maps the row to a leaderboard entry
let db_id = data[0].try_get(0)?;
let db_clicks = data[0].try_get(1)?;
let db_url = data[0].try_get(2)?;

Ok(leaderboard::Entry {
    identifier: db_id,
    clicks: db_clicks,
    url: db_url,
})
</code></pre>
<p>Okay, so I somehow need access to the database handle in the ‚Äúcontrollers‚Äù, like
in <code>controllers::leaderboard</code>.</p>
<blockquote>
<p>I‚Äôm only calling it a controller since it‚Äôs a common concept. <code>axum</code> doesn‚Äôt
call it that.</p>
</blockquote>
<pre><code class="language-rust">let app = Router::new()
    .route("/leaderboard", routing::get(controllers::leaderboard));
</code></pre>
<p><code>axum</code> recommends <sup class="footnote-reference"><a href="#2">2</a></sup> mentions that you could use ‚Äúrequest extensions‚Äù which
looks like it acts like middleware. It recommends to have <code>Arc</code> inhabit
<code>Extension</code> (<code>Extension&lt;Arc&lt;T&gt;&gt;</code>), but why?</p>
<p>Time to do it in some wrong ways. This is fine since <code>rustc</code> is quite helpful
with its error messages.</p>
<p>I‚Äôll try to move <code>handle</code> instead:</p>
<pre><code class="language-rust">use axum::{extract::Extension, routing::get, Router};
use std::net::SocketAddr;

pub async fn run(handle: db::Handle) -&gt; Result&lt;(), hyper::Error&gt; {
    let app = Router::new()
        .route("/leaderboard", routing::get(controllers::leaderboard))
        .layer(Extension(handle));
                      // ^ Here

    let addr = SocketAddr::from(([0, 0, 0, 0], 3000));

    axum::Server::bind(&amp;addr)
        .serve(app.into_make_service())
        .with_graceful_shutdown(signal_shutdown())
        .await
}
</code></pre>
<p>Doing that gives me this error:</p>
<pre><code>error[E0277]: the trait bound `db::Handle: Clone` is not satisfied
  --&gt; src/lib.rs:36:16
   |
36 |         .layer(Extension(handle));
   |          ----- ^^^^^^^^^^^^^^^^^ the trait `Clone` is not implemented for `db::Handle`
   |          |
   |          required by a bound introduced by this call
   |
   = note: required because of the requirements on the impl of `tower_layer::Layer&lt;Route&lt;_&gt;&gt;` for `Extension&lt;db::
Handle&gt;`

For more information about this error, try `rustc --explain E0277`.
</code></pre>
<p>It seems like I need to derive <code>Clone</code> for <code>db::Handle</code> since it probably gets
cloned every time, although I‚Äôm not sure exactly when it does get cloned. In
every new request?</p>
<p>So what happens if I <em>do</em> derive <code>Clone</code>?</p>
<pre><code class="language-rust">#[derive(Clone)]
struct Handle {
  pub pool: Pool
}
</code></pre>
<p>Then I need to make sure that the function‚Äôs type signature matches:</p>
<pre><code class="language-rust">pub async fn leaderboard(
    Extension(handle): Extension&lt;db::Handle&gt;
 // ^ Here! axum seems to know exactly where to apply it to the args. Not sure
 // how this is done (yet).
) -&gt; (StatusCode, Markup) {
    match leaderboard::fetch(&amp;handle).await {
        Ok(entries) =&gt; {
            (StatusCode::OK, views::leaderboard::render(entries))
        },
        Err(_e) =&gt; (StatusCode::INTERNAL_SERVER_ERROR, maud::html! {}),
    }
}
</code></pre>
<p>Well, it seems to compile just fine. The leaderboard page works fine as well.
I don‚Äôt really have that much experience with this yet but my current assumption
is that I‚Äôm required to derive <code>Clone</code> for <code>Handle</code> since there‚Äôs no way to do
shared ownership. So what it does is that it ends up cloning it every time. But,
what if I don‚Äôt want to clone it? What if I just pass around references?</p>
<pre><code class="language-rust">pub async fn run(handle: db::Handle) -&gt; Result&lt;(), hyper::Error&gt; {
    let app = Router::new()
        .route("/leaderboard", routing::get(controllers::leaderboard))
        .layer(Extension(&amp;handle));
                      // ^ Here

    let addr = SocketAddr::from(([0, 0, 0, 0], 3000));

    axum::Server::bind(&amp;addr)
        .serve(app.into_make_service())
        .with_graceful_shutdown(signal_shutdown())
        .await
</code></pre>
<p>Compiles with this helpful error message:</p>
<pre><code>error[E0597]: `handle` does not live long enough
  --&gt; src/lib.rs:36:26
   |
22 |       let app = Router::new()
   |  _______________-
23 | |         .route("/leaderboard", routing::get(controllers::leaderboard))
24 | |         .layer(Extension(&amp;handle));
   | |__________________________^^^^^^^_- argument requires that `handle` is borrowed for `'static`
   |                            |
   |                            borrowed value does not live long enough
...
44 |   }
   |   - `handle` dropped here while still borrowed

For more information about this error, try `rustc --explain E0597`.
</code></pre>
<p>Unfortunately, I‚Äôm not too familiar with how lifetimes work in <code>async</code>/<code>await</code>.
But it looks like since it‚Äôs non-blocking, <code>handle</code> gets dropped since the function
reaches the end of its scope while the server is still running.</p>
<blockquote>
<p>This is all just somewhat smart guessing though. I‚Äôm gonna need to do more
reading on this topic.</p>
</blockquote>
<p>Wait, what about <code>app</code> then? Won‚Äôt this get dropped as well? I wanted to confirm
if this did get moved, or if it did some other trickery I had no idea about:</p>
<pre><code class="language-rust">    let app = Router::new()
        .route("/leaderboard", routing::get(controllers::leaderboard))
        .layer(Extension(handle));

    let addr = SocketAddr::from(([0, 0, 0, 0], 3000));

    let foo =
        axum::Server::bind(&amp;addr)
            .serve(app.into_make_service())
            .with_graceful_shutdown(signal_shutdown())
            .await;

    println!("{:?}", app);

    foo
</code></pre>
<p>So if <code>app</code> does get moved, then <code>rustc</code> should complain about me accessing a
variable with no ownership; which it does:</p>
<pre><code class="language-rust">error[E0382]: borrow of moved value: `app`
   --&gt; src/lib.rs:46:22
    |
22  |     let app = Router::new()
    |         --- move occurs because `app` has type `Router`, which does not implement the `Copy` trait
...
42  |             .serve(app.into_make_service())
    |                        ------------------- `app` moved due to this method call
...
46  |     println!("{:?}", app);
    |                      ^^^ value borrowed here after move
    |
note: this function takes ownership of the receiver `self`, which moves `app`
</code></pre>
<p>Phew! It‚Äôs almost like I‚Äôm encouraged to try out all the failed scenarios to
learn a lot of things since the compiler is quite helpful.</p>
<p>Okay, since I didn‚Äôt want this to get cloned all the time, I will just follow
what <code>axum</code> used in its examples - the usage of <code>Arc&lt;T&gt;</code>:</p>
<pre><code class="language-rust">pub async fn run(handle: db::Handle) -&gt; Result&lt;(), hyper::Error&gt; {
    let handle = Arc::new(handle);
    //  ^ Shadow previous binding with `Arc&lt;db::Handle&gt;`

    let app = Router::new()
        .route("/leaderboard", routing::get(controllers::leaderboard))
        .layer(Extension(handle));
                      // ^ Here

    let addr = SocketAddr::from(([0, 0, 0, 0], 3000));

    axum::Server::bind(&amp;addr)
        .serve(app.into_make_service())
        .with_graceful_shutdown(signal_shutdown())
        .await
}
</code></pre>
<p>And then I‚Äôll remove the <code>Clone</code> derivation:</p>
<pre><code class="language-rust">pub struct Handle {
    pub pool: Pool,
}
</code></pre>
<p>So if I‚Äôm not mistaken, which I probably am, <code>Arc&lt;T&gt;</code> should allow me to share
ownership of <code>db::Handle</code> without having to clone it <sup class="footnote-reference"><a href="#3">3</a></sup>.</p>
<pre><code class="language-rust">pub async fn leaderboard(
    Extension(handle): Extension&lt;Arc&lt;db::Handle&gt;&gt;
) -&gt; (StatusCode, Markup) {
    match leaderboard::fetch(&amp;*handle).await {
        Ok(entries) =&gt; {
            (StatusCode::OK, views::leaderboard::render(entries))
        },
        Err(_e) =&gt; (StatusCode::INTERNAL_SERVER_ERROR, maud::html! {}),
    }
}
</code></pre>
<p>Then in <code>leaderboard::fetch/1</code>:</p>
<pre><code class="language-rust">pub async fn fetch_url(
    handle: &amp;db::Handle,
    identifier: String
) -&gt; Result&lt;String, Error&gt; {
    let client = handle.client().await?;
    let row = client
        .query_one("SELECT app.get_url($1)", &amp;[&amp;identifier])
        .await?;

    row.try_get(0).map_err(|e| Error::from(e))
}
</code></pre>
<p>Although, I had to manually dereference it to get the reference to <code>Handle</code>. It‚Äôs
also a good thing that I don‚Äôt have to mutate <code>handle</code> at all because otherwise
this would‚Äôve been a more painful experience.</p>
<h2>Connecting to a managed database</h2>
<p>Initially, I used <code>sqlx</code> as the db library since it gets recommended in almost
every post about SQL libraries on the Rust subreddit. It worked fine for me
until I had to get it to connect to DO‚Äôs managed DB. It required me to connect
to it via TLS, and it wasn‚Äôt a pleasant experience trying to debug what‚Äôs wrong
with <code>sqlx</code>, so I ditched it settled with <code>tokio-postgres</code>, <code>deadpool-postgres</code>,
and <code>native-tls</code>. Oh, I also had a difficult time <sup class="footnote-reference"><a href="#9">4</a></sup> with <code>rustls</code> since it
didn‚Äôt seem to like DO‚Äôs CA certificate, which is why I settled with <code>native-tls</code>.</p>
<p><code>native-tls</code> needed OpenSSL setup, which I was able to do with Nix (for the
dev environment):</p>
<pre><code class="language-nix">  # ...
        devShell = pkgs.mkShell {
          # inherit (self.checks.${system}.pre-commit-check) shellHook;

          buildInputs = with pkgs; [
            # Back-end
            pkgs.rustc
            pkgs.cargo

            pkgs.openssl
            pkgs.pkg-config
          ];

          PKG_CONFIG_PATH = "${pkgs.openssl.dev}/lib/pkgconfig";
        };

  # ...
</code></pre>
<p>So I had to provide the CA cert during runtime, not build-time since: 1) it‚Äôll
be easier to distribute the static binary and Docker image, and 2) some CA certs
are only given during runtime (like DO if ever you‚Äôre using app platform). This
was my process:</p>
<ol>
<li>Build static binary &amp; image without CA certs and other DB secrets</li>
<li>When the image runs, it‚Äôs assumed that the necessary environment variables,
like one that contains the certificate contents, exist.</li>
<li>Write the certificate contents to a file.</li>
<li>Run <code>emojied</code></li>
</ol>
<p>This seems to be a pretty standard process, although this is fairly tedious.</p>
<pre><code class="language-rust">// src/config.rs
use tokio_postgres::config::SslMode;

let mut pg_config = tokio_postgres::Config::new();

// I also read other PG values like hostname, DB name, user, etc. but excluded
// those for brevity.

// Not providing CA_CERT is fine
let ca_cert_path = match env::var("PG__CA_CERT") {
    Ok(path) =&gt; {
        // I think `Prefer` is fine as well, which is the default
        // for `tokio-postgres`.
        pg_config.ssl_mode(SslMode::Require);
        Some(path)
    },
    Err(_e) =&gt; {
        None
    }
};
</code></pre>
<p>I allowed it to continue running without the cert path in <code>PG__CA_CERT</code> for
dev environments.</p>
<pre><code class="language-rust">// Somewhere in src/db.rs

let manager = match app_config.ca_cert_path {
    Some(ca_cert_path) =&gt; {
        // Read file into byte vector
        let cert = std::fs::read(ca_cert_path)
            .map_err(|e| Error::CACertFileError(e))?;

        // Create a certificate from a PEM file
        let ntls_cert = Certificate::from_pem(&amp;cert)
            .map_err(|_| Error::InvalidCACert)?;

        let tls = TlsConnector::builder()
            .add_root_certificate(ntls_cert)
            .build()
            .map_err(|_| Error::FailedToBuildTlsConnector)?;

        let conn = MakeTlsConnector::new(tls);

        Manager::from_config(app_config.pg, conn, app_config.manager)
    }
    None =&gt; Manager::from_config(app_config.pg, NoTls, app_config.manager),
};

// Since we need a `manager` to build a pool
let pool = Pool::builder(manager)
    .max_size(app_config.pool_size)
    .build()
    .map_err(|_| Error::FailedToBuildPool)?;
</code></pre>
<blockquote>
<p>The process was quite similar with SQLx but there was something, that I don‚Äôt
really remember anymore, which made it so frustrating to work with.</p>
</blockquote>
<p>Unfortunately, DO doesn‚Äôt support multiline environment variables, for some
reason, so cramming everything including the <code>BEGIN CERTIFICATE</code> and <code>END CERTIFICATE</code>
into one line resulted in it getting rejected. So, I just got what‚Äôs in between,
and manually appended it to the file instead.</p>
<pre><code class="language-sh">echo "Dumping CA certificate to /app/ca-certificate.crt"
echo "-----BEGIN CERTIFICATE-----" &gt; /app/ca-certificate.crt
echo $CA_CERT &gt;&gt; /app/ca-certificate.crt
echo "-----END CERTIFICATE-----" &gt;&gt; /app/ca-certificate.crt

echo "Executing emojied"

./emojied
</code></pre>
<p>Kind of hacky, and inconvenient especially if I forget. But it works!</p>
<h2>URL redirect woes</h2>
<p>This is a short one. For the redirect, I returned an HTTP status 301 <sup class="footnote-reference"><a href="#4">5</a></sup> with
a response containing the URL to redirect to. So the process goes something
like this:</p>
<ol>
<li>Enter <a href="https://emojied.net/%F0%9F%8D%8A%F0%9F%8C%90">https://emojied.net/üçäüåê</a> in the browser.</li>
<li><code>emojied</code> looks for an entry with <code>üçäüåê</code>, and gets the associated URL.</li>
<li>Respond with an HTTP 301 and the URL</li>
<li>Browser automatically performs the redirect</li>
</ol>
<p>Unfortunately, and I spent 30mins on this scratching my head why this was
happening, the request would get cached, and this is bad! It‚Äôs bad because I
had to increment the <code>clicks</code> column every time the link is visited. But if it‚Äôs
cached, then the server won‚Äôt bother to call the functions it needs to call!</p>
<p>Then, I found out that <code>301</code> gets cached automatically by the browser <sup class="footnote-reference"><a href="#5">6</a></sup>,
and that I needed to use <code>302</code>.</p>
<h2>HTML templating with <code>maud</code></h2>
<p>I had a pleasant experience with server-side templating while I was building
a Haskell project called <a href="https://swoogle.sekun.dev">swoogle</a>. I used <code>lucid</code>
<sup class="footnote-reference"><a href="#6">7</a></sup> which was a pretty darn elegant HTML DSL.</p>
<pre><code class="language-haskell">-- Category options
select_
  [ id_ "category-options"
  , name_ "resource"
  , class_ "bg-white font-semibold dark:bg-su-dark-bg-alt text-su-fg dark:text-su-dark-fg"
  , required_ "required"
  ] $ do
  option_ [disabled_ "disabled", selected_ "selected", value_ ""] "Category"
  option_ [value_ "people"] "People"
  option_ [value_ "film"] "Film"
  option_ [value_ "starship"] "Starship"
  option_ [value_ "vehicle"] "Vehicle"
  option_ [value_ "species"] "Species"
  option_ [value_ "planet"] "Planet"
</code></pre>
<p>Well, I wanted something like that in Rust, and I found <code>maud</code> <sup class="footnote-reference"><a href="#7">8</a></sup>. I did run
into a problem when I tried to use its latest version with <code>axum</code> since something
must‚Äôve changed in <code>axum</code>, so I had to pull from the <code>main</code> instead:</p>
<pre><code>[dependencies]
...
maud = { git = "https://github.com/lambda-fairy/maud", branch = "main", features = ["axum"] }
...
</code></pre>
<p>So with this, I could do stuff like:</p>
<pre><code class="language-rust">fn foo() -&gt; Markup {
  html! {
    ("Hello")
    h1 class="text-red-500" { ("Hello!") }

    h2 class=("font-semibold") { ("Hey") }
  }
}
</code></pre>
<h2><code>&lt;noscript&gt;</code> tag, and problems with JS toggling extensions</h2>
<p>I wanted to have the website work with JS disabled because, well, it was a very
simple website. There was no reason why I couldn‚Äôt make all the important features
work without JS!</p>
<p>So I ended up making heavy use of the <code>&lt;noscript&gt;</code> tag, since it allowed me to
display alternative content when the browser has JS disabled. You‚Äôll see it
littered all over the codebase, like so:</p>
<pre><code class="language-rust">@match data {
    RootData::Auto(_) =&gt; {
        noscript {
            div class="w-full sm:w-4/5 mt-2 mx-auto text-su-fg-1 dark:text-su-dark-fg-1" {
                a href="?custom_url=t" type="button" class="font-medium underline" {
                    "Custom URL"
                }
            }
        }
    }

    RootData::Custom(_) =&gt; {
        noscript {
            div class="w-full sm:w-4/5 mt-2 mx-auto text-su-fg-1 dark:text-su-dark-fg-1" {
                a href="/" type="button" class="font-medium underline" {
                    "Autogenerate a custom URL for me"
                }
            }
        }
    }
}
</code></pre>
<p>These only get rendered by the browser when JS is disabled. But what do browser
extensions like <code>NoScript</code> when it ‚Äúdisables‚Äù JS? It‚Äôs something like this:</p>
<ol>
<li>Block requests for JS files via CSP (Content Security Policies)</li>
<li>Replace <code>noscript</code> tags to <code>span</code> or <code>div</code> tags</li>
</ol>
<p>The problem I ended up with was in #2. Why? Because the <code>noscript</code> tag attributes
weren‚Äôt copied over to the new <code>span</code>/<code>div</code> tags. And that breaks a lot of stuff.</p>
<p>So while <code>emojied</code> does work without JS, it won‚Äôt work due to how the extensions
work <sup class="footnote-reference"><a href="#8">9</a></sup>.</p>
<h2>Conclusion</h2>
<p>Alright, that was a lot. I did learn a lot from this experience. I actually only
read until chapter 10 of the Rust Book, and skipped to some parts like advanced
traits, and other things. I really like the fact that there‚Äôs a detailed book
that talks about some idiomatic Rust patterns, and even the more advanced stuff,
that‚Äôs completely <strong>FREE</strong>. How crazy is that? My wallet is spared!</p>
<p>I usually try to avoid failure, even in Haskell, cause its error messages are
pretty bad. When I started out, it was pretty much worthless to read GHC‚Äôs error
messages since it would just confuse me even more. It was only until I had people
guide me (like justosophy, thank you) that I slowly got to understand what GHC
was trying to tell me. With Rust though, it‚Äôs a completely different experience.</p>
<p>I like <em>failing</em> because Rust is very helpful with its error messages. In fact,
I discover new things by reading it so I‚Äôm not punished for trying out different
things that don‚Äôt work just to gain more insight.</p>
<p>I also like that it‚Äôs fairly easy on resources. I didn‚Äôt even bother optimizing
this at all since I mostly have no idea what I‚Äôm doing, and I‚Äôm trying to avoid
having to deal with lifetimes as much as possible. I‚Äôm hosting this on a 1x shared
vCPU + 512MB RAM, and it didn‚Äôt break a sweat during peak load.</p>
<p>Anyway, so far, so good! I‚Äôm pretty ecstatic to continue learning Rust.</p>
<h2>Footnotes</h2>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="https://github.com/gnawex/gnawex">https://github.com/gnawex/gnawex</a></p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p><a href="https://docs.rs/axum/0.5.1/axum/#using-request-extensions">https://docs.rs/axum/0.5.1/axum/#using-request-extensions</a></p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p><a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">https://doc.rust-lang.org/std/sync/struct.Arc.html</a></p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">5</sup>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/301">https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/301</a></p>
</div>
<div class="footnote-definition" id="5"><sup class="footnote-definition-label">6</sup>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#targets_of_caching_operations">https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching#targets_of_caching_operations</a></p>
</div>
<div class="footnote-definition" id="6"><sup class="footnote-definition-label">7</sup>
<p><a href="https://hackage.haskell.org/package/lucid">https://hackage.haskell.org/package/lucid</a></p>
</div>
<div class="footnote-definition" id="7"><sup class="footnote-definition-label">8</sup>
<p><a href="https://github.com/lambda-fairy/maud">https://github.com/lambda-fairy/maud</a></p>
</div>
<div class="footnote-definition" id="8"><sup class="footnote-definition-label">9</sup>
<p><a href="https://github.com/hackademix/noscript/issues/238">https://github.com/hackademix/noscript/issues/238</a></p>
</div>
<div class="footnote-definition" id="9"><sup class="footnote-definition-label">4</sup>
<p><a href="https://old.reddit.com/r/rust/comments/txglob/need_help_regarding_deadpoolpostgres_rustls_and/">https://old.reddit.com/r/rust/comments/txglob/need_help_regarding_deadpoolpostgres_rustls_and/</a></p>
</div>
<div class="footnote-definition" id="10"><sup class="footnote-definition-label">10</sup>
<p><a href="https://www.manning.com/books/rust-in-action">https://www.manning.com/books/rust-in-action</a></p>
</div>


    <footer>
  <div>
    Copyright <a href="https://github.com/sekunho">SEKUN</a> 2022-2024.
    Generated by <a href="/projects/puggle"><code>puggle</code></a>.
  </div>
</footer>

    <a rel="me" href="https://mastodon.social/@sekun" style="display: none;">Mastodon</a>
    <script>hljs.highlightAll();</script>

    <script>
      (function attachShadowRoots(root) {
        root.querySelectorAll("template[shadowrootmode]").forEach(template => {
          const mode = template.getAttribute("shadowrootmode");
          const shadowRoot = template.parentNode.attachShadow({ mode });

          shadowRoot.appendChild(template.content);
          template.remove();
          attachShadowRoots(shadowRoot);
        });
      })(document);
    </script>
  </body>
</html>